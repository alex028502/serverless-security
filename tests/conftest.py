import os
import sys
import json
import subprocess
import time
import signal
import uuid

import pytest

from .helpers.fixtures import made_up_path
from .helpers.path import env_with_extended_path


@pytest.fixture()
def email_server(email_config, tmp_path):
    config_dir, config = email_config
    port = config["smtp"]["port"]  # I hope it is free
    messages_folder = "%s/messages" % tmp_path
    # subprocess.run(["rm", "-rf", messages_folder], check=True)
    subprocess.run(["mkdir", messages_folder], check=True)
    process = subprocess.Popen(
        [
            sys.executable,
            "-u",
            "tools/smtp.py",
            str(port),
            messages_folder,
        ]
    )
    time.sleep(1)
    yield [port, messages_folder]
    process.send_signal(signal.SIGINT)
    time.sleep(1)


@pytest.fixture
def dirname():
    # collecting tests gets confused when this is done inline
    # could also be a function
    return os.path.dirname(os.path.realpath(__file__))


@pytest.fixture()
def photos(dirname):
    return [dirname + "/images/red.jpg", dirname + "/images/blue.jpg"]


@pytest.fixture()
def bad_device(photos):
    return made_up_path(photos[0], str(uuid.uuid4())[:5])


@pytest.fixture()
def email_config(dirname):
    directory = dirname + "/config"
    path = directory + "/settings.json"
    with open(path, "r") as settings_file:
        settings = settings_file.read()

    data = json.loads(settings)

    return (directory, data)


@pytest.fixture()
def demo_keys(dirname):
    # array with path to directory and list of additional users
    with open(dirname + "/additional.txt", "r") as additional_file:
        additional = additional_file.read()

    directory = dirname + "/keys"
    return [directory] + additional.strip().split("\n")


def pytest_addoption(parser):
    parser.addoption(
        "--interpreter",
        action="store",
        default=sys.executable,
    )

    parser.addoption(
        "--sut",
        action="store",
        default=os.path.abspath("package"),
    )


@pytest.fixture()
def bin_dir(request):
    # this interpreter should only be used to run the application we are
    # testing - not the
    relative_path = request.config.getoption("--interpreter")
    return os.path.dirname(os.path.abspath(relative_path))


@pytest.fixture()
def sut(request):
    relative_path = request.config.getoption("--sut")
    return os.path.abspath(relative_path)


@pytest.fixture()
def component_env(tmp_path, bin_dir, dirname, email_config):
    # not all components need everything in here but they are all run with the
    # all of these environment variables present, except getting python into
    # the path is done by activating venv normally
    # these are the same environment variables generated by the two entry point
    # program before running subprograms
    # when testing an individual component, we can remove items to prove we
    # don't use them, if we like
    data = tmp_path / "data"
    data.mkdir()
    return {
        "_SECURITY_CAMERA_DATA": str(data),
        "_SECURITY_CAMERA_CONFIG": email_config[0],
        "GPIOZERO_PIN_FACTORY": "mock",
    }


@pytest.fixture()
def action_env_vars(tmp_path):
    # not all components need everything in here but they are all run with the
    # all of these environment variables present, except getting python into
    # the path is done by activating venv normally
    # these are the same environment variables generated by the two entry point
    # program before running subprograms
    # when testing an individual component, we can remove items to prove we
    # don't use them, if we like
    data = tmp_path / "data"
    data.mkdir()
    return {
        "_SECURITY_CAMERA_DATA": str(data),
    }


@pytest.fixture()
def send_env_vars(email_config):
    return {
        "_SECURITY_CAMERA_CONFIG": email_config[0],
    }


@pytest.fixture()
def original_env():
    # add a few keys that need to be removed to our base env to prove we are
    # always removing them
    return dict(
        os.environ,
        SECURITY_CAMERA_X="experimental",
        _SECURITY_CAMERA_X="experimental",
    )


@pytest.fixture()
def plain_env(dirname, original_env):
    env = dict(env_with_extended_path(original_env, "%s/mock/base" % dirname))
    env["GPIOZERO_PIN_FACTORY"] = "unset"
    # we need the system path because of convert and bash
    # and other things in the inherited environment for coverage probably
    # so let's just disable any variables that look like the could belong to
    # our project so that each test can make sure it adds the dependencies
    # so if we have a venv activated or variables exported we won't affect
    # the test result - and cause it to pass when it should fail
    for key in list(env.keys()):
        if "SECURITY_CAMERA" in key:
            env.pop(key)

    return env


# use this for testing the application entry points
@pytest.fixture()
def main_env(plain_env, tmp_path, exe_path, email_config, photos, bad_device):
    subprocess.run(
        ["cp", "-r", email_config[0], tmp_path],
        check=True,
    )
    (tmp_path / "data").mkdir()
    # subprocess.run(
    #     ["mkdir", "%s/data" % tmp_path],
    #     check=True,
    # )

    # there will always be bad devices in the list
    # we pass in /dev/video* in the environment
    # then this gets filtered on startup for the motion sensor
    # and the cron job just tries each one and fails for the bad devices
    devices = " ".join(photos + [bad_device])

    env_vars = {
        "GPIOZERO_PIN_FACTORY": "mock",
        "SECURITY_CAMERA_HOME": str(tmp_path),
        "SECURITY_CAMERA_VENV": os.path.dirname(exe_path["python"]),
        "SECURITY_CAMERA_DEVS": devices,
    }
    return env_with_extended_path(
        dict(os.environ, **env_vars), exe_path["fswebcam"]
    )


@pytest.fixture()
def exe_path(dirname, bin_dir):
    # paths to put in PATH
    return {
        "fswebcam": "%s/mock/fswebcam" % dirname,
        "convert": "%s/mock/convert" % dirname,
        "python": bin_dir,
    }

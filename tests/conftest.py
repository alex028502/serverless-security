import os
import sys
import json
import subprocess
import time
import signal
import uuid

import pytest

from .helpers.fixtures import made_up_path


@pytest.fixture()
def email_server(email_config, tmp_path):
    config_dir, config = email_config
    port = config["smtp"]["port"]  # I hope it is free
    messages_folder = "%s/messages" % tmp_path
    # subprocess.run(["rm", "-rf", messages_folder], check=True)
    subprocess.run(["mkdir", messages_folder], check=True)
    process = subprocess.Popen(
        [
            sys.executable,
            "-u",
            "tools/smtp.py",
            str(port),
            messages_folder,
        ]
    )
    time.sleep(1)
    yield [port, messages_folder]
    process.send_signal(signal.SIGINT)
    time.sleep(1)


@pytest.fixture
def dirname():
    # collecting tests gets confused when this is done inline
    # could also be a function
    return os.path.dirname(os.path.realpath(__file__))


@pytest.fixture()
def photos(dirname):
    return [dirname + "/images/red.jpg", dirname + "/images/blue.jpg"]


@pytest.fixture()
def bad_device(photos):
    return made_up_path(photos[0], str(uuid.uuid4())[:5])


@pytest.fixture()
def email_config(dirname):
    directory = dirname + "/config"
    path = directory + "/settings.json"
    with open(path, "r") as settings_file:
        settings = settings_file.read()

    data = json.loads(settings)

    return (directory, data)


@pytest.fixture()
def demo_keys(dirname):
    # array with path to directory and list of additional users
    with open(dirname + "/additional.txt", "r") as additional_file:
        additional = additional_file.read()

    directory = dirname + "/keys"
    return [directory] + additional.strip().split("\n")


def pytest_addoption(parser):
    parser.addoption(
        "--interpreter",
        action="store",
        default=sys.executable,
    )

    parser.addoption(
        "--sut",
        action="store",
        default=os.path.abspath("package"),
    )


@pytest.fixture()
def bin_dir(request):
    # this interpreter should only be used to run the application we are
    # testing - not the
    relative_path = request.config.getoption("--interpreter")
    return os.path.dirname(os.path.abspath(relative_path))


@pytest.fixture()
def sut(request):
    relative_path = request.config.getoption("--sut")
    return os.path.abspath(relative_path)


@pytest.fixture()
def component_env(tmp_path, bin_dir, dirname, email_config):
    # not all components need everything in here but they are all run with the
    # all of these environment variables present, except getting python into
    # the path is done by activating venv normally
    # these are the same environment variables generated by the two entry point
    # program before running subprograms
    # when testing an individual component, we can remove items to prove we
    # don't use them, if we like
    data = tmp_path / "data"
    data.mkdir()
    return {
        # don't try to change the path like this in two places!
        "PATH": "%s:%s/mock:%s" % (bin_dir, dirname, os.environ["PATH"]),
        "_SECURITY_CAMERA_DATA": str(data),
        "_SECURITY_CAMERA_CONFIG": email_config[0],
        "GPIOZERO_PIN_FACTORY": "mock",
    }


# use this for testing the application entry points
@pytest.fixture()
def main_env(tmp_path, bin_dir, dirname, email_config, photos, bad_device):
    subprocess.run(
        ["cp", "-r", email_config[0], tmp_path],
        check=True,
    )
    (tmp_path / "data").mkdir()
    # subprocess.run(
    #     ["mkdir", "%s/data" % tmp_path],
    #     check=True,
    # )

    # there will always be bad devices in the list trying to take a picture and
    # detecting all devices are the same process
    devices = " ".join(photos + [bad_device])

    return {
        "PATH": "%s/mock:%s" % (dirname, os.environ["PATH"]),  # be careful
        "GPIOZERO_PIN_FACTORY": "mock",
        "SECURITY_CAMERA_HOME": str(tmp_path),
        "SECURITY_CAMERA_VENV": os.path.dirname(bin_dir),
        "SECURITY_CAMERA_DEVS": devices,
    }
